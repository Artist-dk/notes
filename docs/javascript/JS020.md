# ğŸ”¥ **Recursion in JavaScript: Recursive Functions & Use Cases**  

Recursion is a fundamental programming concept where a function **calls itself** to solve a problem. It's particularly useful for problems that can be broken down into **smaller subproblems** of the same type.

In this guide, weâ€™ll cover:  
âœ… **What is Recursion?** â€“ The concept explained.  
âœ… **Recursive Function Structure** â€“ Base case & recursive case.  
âœ… **Examples of Recursion** â€“ Factorial, Fibonacci, Array sum, Object traversal, etc.  
âœ… **Optimizing Recursion** â€“ Tail recursion, Memoization.  
âœ… **Use Cases** â€“ Where recursion is useful.  

---

## ğŸ”· **1. What is Recursion?**
**Recursion** is a technique where a function **calls itself** until a specific **base condition** is met.  

ğŸ”¹ A recursive function has two key parts:  
1ï¸âƒ£ **Base Case** â€“ The stopping condition to prevent infinite recursion.  
2ï¸âƒ£ **Recursive Case** â€“ The function calls itself with a **smaller subproblem**.  

### ğŸ”¹ **Example: A Simple Recursive Function**
```js
function countDown(n) {
    if (n <= 0) {
        console.log("Done!");
        return; // Base case
    }
    console.log(n);
    countDown(n - 1); // Recursive case
}

countDown(5);
/* Output:
5
4
3
2
1
Done!
*/
```
âœ” `countDown(5)` calls `countDown(4)`, which calls `countDown(3)`, and so on **until `n === 0`**.  

---

## ğŸ”· **2. Factorial Using Recursion**
ğŸ’¡ **Factorial** of `n` (`n!`) is defined as:
\[
n! = n \times (n-1) \times (n-2) \times \dots \times 1
\]
Example:  
`5! = 5 Ã— 4 Ã— 3 Ã— 2 Ã— 1 = 120`  

### ğŸ”¹ **Factorial Function (Recursive)**
```js
function factorial(n) {
    if (n === 0 || n === 1) {
        return 1; // Base case
    }
    return n * factorial(n - 1); // Recursive case
}

console.log(factorial(5)); // Output: 120
```
âœ” **Base Case:** `factorial(0) = 1`  
âœ” **Recursive Case:** `factorial(n) = n * factorial(n-1)`  

---

## ğŸ”· **3. Fibonacci Series Using Recursion**
ğŸ’¡ The Fibonacci sequence is:
\[
F(n) = F(n-1) + F(n-2)
\]
Example:
```
0, 1, 1, 2, 3, 5, 8, 13, 21, ...
```

### ğŸ”¹ **Recursive Fibonacci Function**
```js
function fibonacci(n) {
    if (n <= 1) {
        return n; // Base case
    }
    return fibonacci(n - 1) + fibonacci(n - 2); // Recursive case
}

console.log(fibonacci(6)); // Output: 8
```
âœ” The function keeps calling itself until `n === 0` or `n === 1`.  

---

## ğŸ”· **4. Sum of an Array Using Recursion**
ğŸ’¡ Instead of using a loop, recursion can be used to sum an array.

### ğŸ”¹ **Recursive Sum Function**
```js
function sumArray(arr, n) {
    if (n <= 0) {
        return 0; // Base case
    }
    return arr[n - 1] + sumArray(arr, n - 1); // Recursive case
}

const numbers = [1, 2, 3, 4, 5];
console.log(sumArray(numbers, numbers.length)); // Output: 15
```
âœ” Each recursive call **adds the last element** and calls itself with a smaller array.  

---

## ğŸ”· **5. Traversing a Nested Object Recursively**
ğŸ’¡ If you have deeply nested objects, recursion helps navigate them.

### ğŸ”¹ **Example: Print All Values in a Nested Object**
```js
const nestedObj = {
    name: "Alice",
    info: {
        age: 25,
        address: {
            city: "New York",
            zip: 10001
        }
    }
};

function printValues(obj) {
    for (let key in obj) {
        if (typeof obj[key] === "object") {
            printValues(obj[key]); // Recursive case
        } else {
            console.log(`${key}: ${obj[key]}`);
        }
    }
}

printValues(nestedObj);
/* Output:
name: Alice
age: 25
city: New York
zip: 10001
*/
```
âœ” **Base Case:** Stops when there are no more nested objects.  
âœ” **Recursive Case:** Calls itself for each nested object.  

---

## ğŸ”· **6. Optimizing Recursion**
Recursive functions can be inefficient if they perform redundant calculations.  
### ğŸ”¹ **Solution 1: Memoization (Storing Results)**
```js
function fibonacciMemoized(n, memo = {}) {
    if (n in memo) return memo[n]; // Check if value exists in memo
    if (n <= 1) return n; // Base case
    memo[n] = fibonacciMemoized(n - 1, memo) + fibonacciMemoized(n - 2, memo);
    return memo[n];
}

console.log(fibonacciMemoized(50)); // Output: 12586269025 (Fast!)
```
âœ” **Avoids redundant calculations** by storing previously computed values.  

### ğŸ”¹ **Solution 2: Tail Recursion**
Some languages optimize recursion by **removing stack frames** in **tail-recursive functions**.  
JavaScript **does not always support Tail Call Optimization (TCO)**, but you can **rewrite recursion iteratively** when needed.

---

## ğŸ”· **7. Use Cases of Recursion**
ğŸ“Œ **Data Structures:**  
âœ… Traversing **Trees & Graphs**  
âœ… Searching in **Linked Lists**  
âœ… Sorting algorithms (**Merge Sort, Quick Sort**)  

ğŸ“Œ **Mathematical Computations:**  
âœ… **Factorial, Fibonacci, Exponentiation**  

ğŸ“Œ **File System Operations:**  
âœ… **Recursively reading directories**  

ğŸ“Œ **DOM Manipulation in JavaScript:**  
âœ… Finding elements in a **nested HTML structure**  

ğŸ“Œ **Backtracking Problems:**  
âœ… Solving **Sudoku, N-Queens Problem, Maze Solving**  

---

## ğŸ”¥ **Final Summary**
âœ” **Recursion** is when a function calls itself to solve a problem.  
âœ” **Base case** is crucial to prevent infinite recursion.  
âœ” **Common examples:** Factorial, Fibonacci, Array sum, Nested object traversal.  
âœ” **Optimization techniques:** Memoization, Tail Recursion.  
âœ” **Real-world applications:** Data structures, algorithms, file systems, DOM manipulation.  

Would you like some **interview-style recursion challenges**? ğŸš€