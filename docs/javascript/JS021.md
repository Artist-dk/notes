# ğŸ”¥ **Callbacks & Handling Asynchronous Code in JavaScript**  

JavaScript is **single-threaded** and uses an **event-driven** model to handle **asynchronous operations**. One of the primary ways to handle async code is using **callbacks**.  

In this guide, weâ€™ll cover:  
âœ… **What is a Callback Function?**  
âœ… **Synchronous vs Asynchronous Callbacks**  
âœ… **Callback Hell & Issues with Callbacks**  
âœ… **Handling Async Code with Callbacks (Real-world Examples)**  
âœ… **Alternatives to Callbacks: Promises & Async/Await**  

---

## ğŸ”· **1. What is a Callback Function?**
A **callback function** is a function that is **passed as an argument** to another function and is **executed later**.

### ğŸ”¹ **Example: Basic Callback Function**
```js
function greet(name, callback) {
    console.log("Hello, " + name);
    callback();
}

function afterGreeting() {
    console.log("Welcome to JavaScript!");
}

greet("Alice", afterGreeting);
/* Output:
Hello, Alice
Welcome to JavaScript!
*/
```
âœ” `greet("Alice", afterGreeting)` **calls `afterGreeting()` as a callback** after logging the greeting.

---

## ğŸ”· **2. Synchronous vs Asynchronous Callbacks**
Callbacks can be **synchronous** or **asynchronous** depending on how they are used.

### âœ… **Synchronous Callback (Executed Immediately)**
```js
function processNumber(num, callback) {
    let result = num * 2;
    callback(result);
}

processNumber(5, function (res) {
    console.log("Result:", res); // Output: Result: 10
});
```
âœ” The callback is executed **immediately** after `processNumber()` completes.

---

### âœ… **Asynchronous Callback (Executed Later)**
When dealing with **I/O operations**, callbacks are executed **after a delay**.

#### ğŸ”¹ **Example: Using `setTimeout()`**
```js
console.log("Start");

setTimeout(function () {
    console.log("Executed after 2 seconds");
}, 2000);

console.log("End");
/* Output:
Start
End
Executed after 2 seconds
*/
```
âœ” `setTimeout()` executes the callback **after 2 seconds**, allowing the rest of the code to continue.

---

## ğŸ”· **3. Handling Async Operations Using Callbacks**
JavaScript handles **asynchronous operations** like:
âœ… **Reading files**  
âœ… **Fetching data from an API**  
âœ… **Database queries**  
âœ… **User input events**  

### ğŸ”¹ **Example: Simulating an API Call Using Callbacks**
```js
function fetchData(callback) {
    console.log("Fetching data...");

    setTimeout(() => {
        let data = { name: "Alice", age: 25 };
        callback(data); // Call the callback function after 2 seconds
    }, 2000);
}

function displayData(data) {
    console.log("Received data:", data);
}

fetchData(displayData);
/* Output:
Fetching data...
Received data: { name: 'Alice', age: 25 }
*/
```
âœ” `fetchData()` **fetches data asynchronously** and calls `displayData()` once the data is ready.

---

## ğŸ”· **4. Callback Hell (Pyramid of Doom)**
When multiple **nested callbacks** are used, the code becomes **hard to read and debug**. This is called **Callback Hell**.

### ğŸ”¹ **Example: Nested Callbacks**
```js
function step1(callback) {
    setTimeout(() => {
        console.log("Step 1 completed");
        callback();
    }, 1000);
}

function step2(callback) {
    setTimeout(() => {
        console.log("Step 2 completed");
        callback();
    }, 1000);
}

function step3(callback) {
    setTimeout(() => {
        console.log("Step 3 completed");
        callback();
    }, 1000);
}

step1(() => {
    step2(() => {
        step3(() => {
            console.log("All steps completed");
        });
    });
});
/* Output:
Step 1 completed
Step 2 completed
Step 3 completed
All steps completed
*/
```
ğŸ˜µ **Issues with Callback Hell:**  
âŒ Code is **hard to read**.  
âŒ **Difficult to maintain** if steps change.  
âŒ Error handling becomes **complex**.  

---

## ğŸ”· **5. Avoiding Callback Hell**
### âœ… **Solution 1: Named Functions Instead of Anonymous Callbacks**
Using **named functions** improves readability.

```js
function step1(callback) {
    setTimeout(() => {
        console.log("Step 1 completed");
        callback();
    }, 1000);
}

function step2(callback) {
    setTimeout(() => {
        console.log("Step 2 completed");
        callback();
    }, 1000);
}

function step3(callback) {
    setTimeout(() => {
        console.log("Step 3 completed");
        callback();
    }, 1000);
}

function executeSteps() {
    step1(step2.bind(null, step3.bind(null, () => console.log("All steps completed"))));
}

executeSteps();
```
âœ” Reduces **indentation levels**.  
âœ” **Easier to debug** and maintain.  

---

### âœ… **Solution 2: Using Promises Instead of Callbacks**
Instead of using nested callbacks, JavaScript introduced **Promises**, which allow **chaining `.then()` instead of nesting callbacks**.

```js
function step1() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Step 1 completed");
            resolve();
        }, 1000);
    });
}

function step2() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Step 2 completed");
            resolve();
        }, 1000);
    });
}

function step3() {
    return new Promise((resolve) => {
        setTimeout(() => {
            console.log("Step 3 completed");
            resolve();
        }, 1000);
    });
}

step1()
    .then(step2)
    .then(step3)
    .then(() => console.log("All steps completed"));
```
âœ” **Eliminates nesting** and improves readability.  

---

### âœ… **Solution 3: Using Async/Await for Cleaner Code**
JavaScript **`async/await`** syntax simplifies handling async operations.

```js
async function executeSteps() {
    await step1();
    await step2();
    await step3();
    console.log("All steps completed");
}

executeSteps();
```
âœ” **Looks synchronous** but executes asynchronously.  
âœ” **No need for `.then()` chaining**.  

---

## ğŸ”· **6. When to Use Callbacks vs Promises vs Async/Await?**
| Feature        | Callbacks | Promises | Async/Await |
|---------------|----------|---------|-------------|
| **Readability** | âŒ Hard to read | âœ… Easier than callbacks | âœ…âœ… Very clean syntax |
| **Error Handling** | âŒ Complex | âœ… `.catch()` handles errors | âœ… Try/Catch blocks |
| **Chaining Operations** | âŒ Leads to Callback Hell | âœ… `.then()` makes chaining easy | âœ… Await makes code synchronous-like |
| **Performance** | âœ… Fast | âœ… Fast | âœ… Fast |

âœ” **Use Callbacks** for **simple tasks** like event handling (`onClick`).  
âœ” **Use Promises** when dealing with **asynchronous tasks** (`fetch API`).  
âœ” **Use Async/Await** for **readable, sequential async code**.  

---

## ğŸ”¥ **Final Summary**
âœ” **Callbacks** are functions passed as arguments to be executed later.  
âœ” Used for **asynchronous operations** like API calls, file handling, and timers.  
âœ” **Callback Hell** occurs when too many nested callbacks make code unreadable.  
âœ” **Promises & Async/Await** solve callback issues by making code more readable.  

Would you like **interview-style questions** on callbacks? ğŸš€