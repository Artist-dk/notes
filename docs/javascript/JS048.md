# ğŸ“Œ **Observer Pattern in JavaScript**  
The **Observer Pattern** is a **behavioral design pattern** used in event-driven programming where an **object (subject)** maintains a list of **dependents (observers)** and notifies them **automatically** of any changes in its state.  

It is widely used in **real-time applications**, **event-driven programming**, and **publish-subscribe (Pub/Sub) mechanisms**.

---

## ğŸ”¥ **1ï¸âƒ£ Key Concepts of Observer Pattern**
### âœ… **Components of Observer Pattern**
1. **Subject (Observable)** â†’ The main object that **maintains the state** and **notifies observers** when a change occurs.
2. **Observers (Subscribers)** â†’ The dependent objects that **react** to changes in the subject.
3. **Subscribe()** â†’ Method to **add** an observer to the subject.
4. **Unsubscribe()** â†’ Method to **remove** an observer from the subject.
5. **Notify()** â†’ Method to **inform all subscribed observers** of changes.

---

## ğŸ¯ **2ï¸âƒ£ Why Use the Observer Pattern?**
| âœ… **Advantages** | âŒ **Disadvantages** |
|------------------|--------------------|
| **Decouples** objects (Loose coupling) | Can lead to **unexpected behavior** if not managed correctly |
| Enhances **scalability** | Harder to debug due to **indirect execution** |
| Improves **modularity** | **Performance issues** if many observers exist |

---

## ğŸ“Œ **3ï¸âƒ£ Basic Implementation of Observer Pattern in JavaScript**
### ğŸ”¹ **Implementing a Simple Observer Pattern**
```js
class Subject {
    constructor() {
        this.observers = []; // List of observers
    }

    subscribe(observer) {
        this.observers.push(observer);
    }

    unsubscribe(observer) {
        this.observers = this.observers.filter(obs => obs !== observer);
    }

    notify(data) {
        this.observers.forEach(observer => observer(data));
    }
}

// âœ… Usage
const subject = new Subject();

const observer1 = (data) => console.log(`Observer 1 received: ${data}`);
const observer2 = (data) => console.log(`Observer 2 received: ${data}`);

subject.subscribe(observer1);
subject.subscribe(observer2);

subject.notify("Hello Observers!"); 
// Output: 
// Observer 1 received: Hello Observers!
// Observer 2 received: Hello Observers!

subject.unsubscribe(observer1);
subject.notify("Second notification");
// Output: 
// Observer 2 received: Second notification
```

### ğŸ”¥ **How It Works?**
- `Subject` **manages a list of observers**.
- `subscribe(observer)` â†’ Adds an observer to the list.
- `unsubscribe(observer)` â†’ Removes an observer from the list.
- `notify(data)` â†’ Calls all observers with updated data.

---

## ğŸ“Œ **4ï¸âƒ£ Observer Pattern with JavaScript Classes**
```js
class Subject {
    constructor() {
        this.observers = new Set(); // Set to store unique observers
    }

    subscribe(observer) {
        this.observers.add(observer);
    }

    unsubscribe(observer) {
        this.observers.delete(observer);
    }

    notify(data) {
        this.observers.forEach(observer => observer.update(data));
    }
}

class Observer {
    constructor(name) {
        this.name = name;
    }

    update(data) {
        console.log(`${this.name} received update: ${data}`);
    }
}

// âœ… Usage
const subject = new Subject();

const observerA = new Observer("Observer A");
const observerB = new Observer("Observer B");

subject.subscribe(observerA);
subject.subscribe(observerB);

subject.notify("Event 1 occurred!");
// Output: 
// Observer A received update: Event 1 occurred!
// Observer B received update: Event 1 occurred!

subject.unsubscribe(observerB);
subject.notify("Event 2 occurred!");
// Output: 
// Observer A received update: Event 2 occurred!
```

---

## ğŸ“Œ **5ï¸âƒ£ Observer Pattern in Real-World Scenarios**
### ğŸ”¹ **1. DOM Event Listeners (Built-in Observer)**
JavaScript **event listeners** follow the Observer Pattern!

```js
document.addEventListener("click", () => console.log("Click event triggered!"));
```
ğŸš€ **Each click handler acts as an observer!**

---

### ğŸ”¹ **2. Observer Pattern for Chat Applications**
```js
class ChatRoom {
    constructor() {
        this.users = [];
    }

    join(user) {
        this.users.push(user);
    }

    leave(user) {
        this.users = this.users.filter(u => u !== user);
    }

    sendMessage(message, sender) {
        this.users.forEach(user => {
            if (user !== sender) {
                user.receiveMessage(message, sender);
            }
        });
    }
}

class User {
    constructor(name) {
        this.name = name;
    }

    receiveMessage(message, sender) {
        console.log(`${this.name} received: ${message} from ${sender.name}`);
    }
}

// âœ… Usage
const chatRoom = new ChatRoom();
const user1 = new User("Alice");
const user2 = new User("Bob");

chatRoom.join(user1);
chatRoom.join(user2);

chatRoom.sendMessage("Hello!", user1);
// Output:
// Bob received: Hello! from Alice
```

---

## ğŸ“Œ **6ï¸âƒ£ Observer Pattern with EventEmitter (Node.js)**
Node.js provides **built-in support** for Observer Pattern using **EventEmitter**.

```js
const EventEmitter = require("events");

class MyEmitter extends EventEmitter {}

const myEmitter = new MyEmitter();

// âœ… Adding Observers
myEmitter.on("message", (msg) => console.log(`Observer 1: ${msg}`));
myEmitter.on("message", (msg) => console.log(`Observer 2: ${msg}`));

// âœ… Triggering an Event
myEmitter.emit("message", "Hello Observers!");
// Output:
// Observer 1: Hello Observers!
// Observer 2: Hello Observers!
```
ğŸš€ **Used in real-world applications** like WebSockets, HTTP servers, etc.

---

## ğŸ“Œ **7ï¸âƒ£ Observer Pattern vs. Publish-Subscribe (Pub/Sub)**
| Feature | Observer Pattern | Pub/Sub Pattern |
|---------|-----------------|----------------|
| **Direct Communication** | Observers are **directly attached** to the Subject | Subscribers **listen** to a centralized Event Bus |
| **Loose Coupling** | Observers are **aware of the subject** | Publishers **donâ€™t know** who the subscribers are |
| **Scalability** | Limited to small-scale applications | Better for **large-scale distributed systems** |

ğŸ”¹ **Observer Pattern** â†’ **Tightly coupled** objects (Direct interaction)  
ğŸ”¹ **Pub/Sub** â†’ **Decoupled** using an event broker (Better for large-scale apps)

---

## ğŸ¯ **Final Thoughts**
âœ” **Observer Pattern** enables real-time event handling.  
âœ” Used in **DOM events, WebSockets, Chat apps, and Node.js EventEmitters**.  
âœ” Can be implemented using **Event Listeners, Classes, or EventEmitters**.  
âœ” **Pub/Sub** is a more **scalable** alternative in distributed systems.  

ğŸš€ **Next Step:** Try implementing **Observer Pattern in a React App** using **Context API or Redux**!